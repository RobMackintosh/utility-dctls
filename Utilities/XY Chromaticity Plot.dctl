#line 2

// clang-format off

DEFINE_UI_PARAMS(scope_pos_x, Scope Position X, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(scope_pos_y, Scope Position Y, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(scope_size, Scope Size, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(scope_opacity, Scope Opacity, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(scope_saturation, Scope Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(dot_size, Scope Dot Size, DCTLUI_SLIDER_FLOAT, 4.0, 0.0, 10.0, 0.01)
DEFINE_UI_PARAMS(dot_opacity, Scope Dot Opacity, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(zoom, Zoom, DCTLUI_SLIDER_FLOAT, 1.0, 0.10, 2.0, 0.01)

DEFINE_UI_PARAMS(num_x_samples, Num X Samples, DCTLUI_SLIDER_INT, 100, 1, 300, 1)
DEFINE_UI_PARAMS(num_y_samples, Num Y Samples, DCTLUI_SLIDER_INT, 50, 1, 300, 1)

DEFINE_UI_PARAMS(ignore_magnitude_below, Ignore Mag Below, DCTLUI_VALUE_BOX, 0.02)
DEFINE_UI_PARAMS(ignore_xyz_sum_below, Ignore XYZ Sum Below, DCTLUI_VALUE_BOX, 0.0)
DEFINE_UI_PARAMS(source_red_x, Custom Red x, DCTLUI_VALUE_BOX, 0.64)
DEFINE_UI_PARAMS(source_red_y, Custom Red y, DCTLUI_VALUE_BOX, 0.33)
DEFINE_UI_PARAMS(source_green_x, Custom Green x, DCTLUI_VALUE_BOX, 0.3)
DEFINE_UI_PARAMS(source_green_y, Custom Green y, DCTLUI_VALUE_BOX, 0.6)
DEFINE_UI_PARAMS(source_blue_x, Custom Blue x, DCTLUI_VALUE_BOX, 0.15)
DEFINE_UI_PARAMS(source_blue_y, Custom Blue y, DCTLUI_VALUE_BOX, 0.06)
DEFINE_UI_PARAMS(source_white_x, Custom White x, DCTLUI_VALUE_BOX, 0.3127)
DEFINE_UI_PARAMS(source_white_y, Custom White y, DCTLUI_VALUE_BOX, 0.3290)

DEFINE_UI_PARAMS(draw_grid, Draw Grid, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(draw_overlay_triangle, Draw Overlay Bounds, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(draw_target_triangle, Draw Working Bounds, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(draw_xyz_triangle, Draw XYZ Bounds, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(draw_spectral_locus, Draw Spectral Locus, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(draw_white_point, Draw White Point, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(invert, Swap XYZ and Camera Observer, DCTLUI_CHECK_BOX, 0)

DEFINE_UI_PARAMS(source_gamut, Working Primaries, DCTLUI_COMBO_BOX, 6, {SRC_GAMUT_CUSTOM, SRC_GAMUT_ACES_AP0, SRC_GAMUT_ACES_AP1, SRC_GAMUT_AWG3, SRC_GAMUT_AWG4, SRC_GAMUT_CANON_CINEMA_GAMUT, SRC_GAMUT_DWG, SRC_GAMUT_EGAMUT, SRC_GAMUT_EGAMUT2, SRC_GAMUT_P3_D65, SRC_GAMUT_REC709, SRC_GAMUT_REC2020, SRC_GAMUT_REDWIDEGAMUTRGB, SRC_GAMUT_SGAMUT3, SRC_GAMUT_SGAMUT3CINE, SRC_GAMUT_XYZ}, {Custom, ACES AP0, ACES AP1, ARRI Wide Gamut 3, ARRI Wide Gamut 4, Canon Cinema Gamut, DaVinci Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut 2, P3 D65, Rec. 709, Rec. 2020, RedWideGamutRGB, Sony S-Gamut3, Sony S-Gamut3.Cine, XYZ})

DEFINE_UI_PARAMS(overlay_gamut, Overlay Primaries, DCTLUI_COMBO_BOX, 10, {OVERLAY_GAMUT_CUSTOM, OVERLAY_GAMUT_ACES_AP0, OVERLAY_GAMUT_ACES_AP1, OVERLAY_GAMUT_AWG3, OVERLAY_GAMUT_AWG4, OVERLAY_GAMUT_CANON_CINEMA_GAMUT, OVERLAY_GAMUT_DWG, OVERLAY_GAMUT_EGAMUT, OVERLAY_GAMUT_EGAMUT2, OVERLAY_GAMUT_P3_D65, OVERLAY_GAMUT_REC709, OVERLAY_GAMUT_REC2020, OVERLAY_GAMUT_REDWIDEGAMUTRGB, OVERLAY_GAMUT_SGAMUT3, OVERLAY_GAMUT_SGAMUT3CINE, OVERLAY_GAMUT_XYZ}, {Custom, ACES AP0, ACES AP1, ARRI Wide Gamut 3, ARRI Wide Gamut 4, Canon Cinema Gamut, DaVinci Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut 2, P3 D65, Rec. 709, Rec. 2020, RedWideGamutRGB, Sony S-Gamut3, Sony S-Gamut3.Cine, XYZ})

// clang-format on

#define PI (3.14159265358979323f)

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ inline float pow2f(float base) {
    return base * base;
}

__DEVICE__ inline float rad_to_deg(float deg) {
    return deg * 360.0f / (2.0f * PI);
}

__DEVICE__ inline float deg_to_rad(float rad) {
    return rad * (2.0f * PI) / 360.0f;
}

// Linalg

__DEVICE__ void make_rotation_mat_axis_angle(float mat[3][3], float3 axis, float angle) {
    // Axis assumed to be unit vector, angle assuemd to be in radians
    float c = _cosf(angle);
    float s = _sinf(angle);

    mat[0][0] = c + pow2f(axis.x) * (1.0f - c);
    mat[0][1] = axis.x * axis.y * (1.0f - c) - axis.z * s;
    mat[0][2] = axis.x * axis.z * (1.0f - c) + axis.y * s;
    mat[1][0] = axis.x * axis.y * (1.0f - c) + axis.z * s;
    mat[1][1] = c + pow2f(axis.y) * (1.0f - c);
    mat[1][2] = axis.y * axis.z * (1.0f - c) - axis.x * s;
    mat[2][0] = axis.z * axis.x * (1.0f - c) - axis.y * s;
    mat[2][1] = axis.z * axis.y * (1.0f - c) + axis.x * s;
    mat[2][2] = c + pow2f(axis.z) * (1.0f - c);
}

__DEVICE__ float3 cross_product(float3 a, float3 b) {
    float3 out = make_float3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
    return out;
}

__DEVICE__ float dot_product(float3 a, float3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

__DEVICE__ float norm_f3(float3 a) {
    return _sqrtf(pow2f(a.x) + pow2f(a.y) + pow2f(a.z));
}

__DEVICE__ float3 unit_vec(float3 a) {
    float norm = _sqrtf(pow2f(a.x) + pow2f(a.y) + pow2f(a.z));
    float3 out = make_float3(a.x / norm, a.y / norm, a.z / norm);
    return out;
}

// Matrix math
__DEVICE__ float3 mv_33_3(float mat[3][3], float3 v) {
    // matrix * vector multiplication
    float3 out = make_float3(mat[0][0] * v.x + mat[0][1] * v.y + mat[0][2] * v.z,
                             mat[1][0] * v.x + mat[1][1] * v.y + mat[1][2] * v.z,
                             mat[2][0] * v.x + mat[2][1] * v.y + mat[2][2] * v.z);
    return out;
}

__DEVICE__ void copy_mat_33(float to[3][3], float from[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            to[i][j] = from[i][j];
        }
    }
}

__DEVICE__ void mm_33_33(float dest[3][3], float a[3][3], float b[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = dot_product(make_float3(a[i][0], a[i][1], a[i][2]), make_float3(b[0][j], b[1][j], b[2][j]));
        }
    }
}

__DEVICE__ void mat_inverse_33(float dest[3][3], float m[3][3]) {
    // from https://ardoris.wordpress.com/2008/07/18/general-formula-for-the-inverse-of-a-3x3-matrix/

    float det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

    dest[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
    dest[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
    dest[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
    dest[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
    dest[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
    dest[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
    dest[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
    dest[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
    dest[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
}

__DEVICE__ void mat_transpose_33(float m[3][3]) {
    float temp;
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            temp = m[i][j];
            m[i][j] = m[j][i];
            m[j][i] = temp;
        }
    }
}

__DEVICE__ void mat_fill(float dest[3][3], float fill) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = fill;
        }
    }
}

__DEVICE__ void diagonal_matrix(float dest[3][3], float3 diagonal) {
    mat_fill(dest, 0.0f);
    dest[0][0] = diagonal.x;
    dest[1][1] = diagonal.y;
    dest[2][2] = diagonal.z;
}

__DEVICE__ void identity_matrix(float dest[3][3]) {
    diagonal_matrix(dest, make_float3(1.0f, 1.0f, 1.0f));
}

// Inclusive on bounds. Assume left_bottom <= right_top
typedef struct {
        int2 left_bottom; // to be specified in terms of cartesian pixel coordinates
        int2 right_top;
} bounding_box_t;

__DEVICE__ bounding_box_t make_bounding_box(int2 left_bottom, int2 right_top) {
    bounding_box_t box = {};
    box.left_bottom = left_bottom;
    box.right_top = right_top;
    return box;
}

__DEVICE__ inline bool inside_bounding_box(float2 curr_pos, bounding_box_t box) {
    return (box.left_bottom.x <= curr_pos.x && curr_pos.x <= box.right_top.x && box.left_bottom.y <= curr_pos.y && curr_pos.y <= box.right_top.y);
}

typedef struct {
        float2 red_xy;
        float2 green_xy;
        float2 blue_xy;
        float2 white_xy;
} gamut_primaries_t;

__DEVICE__ gamut_primaries_t make_gamut_primaries(float2 red_xy, float2 green_xy, float2 blue_xy, float2 white_xy) {
    gamut_primaries_t gamut_primaries;
    gamut_primaries.red_xy = red_xy;
    gamut_primaries.green_xy = green_xy;
    gamut_primaries.blue_xy = blue_xy;
    gamut_primaries.white_xy = white_xy;
    return gamut_primaries;
}

__DEVICE__ float3 xy_to_XYZ(float2 xy) {
    float3 xyz = make_float3(xy.x / xy.y, 1.0f, (1.0f - xy.x - xy.y) / xy.y);
    if (xy.y == 0.0f) {
        xyz = make_float3(xy.x, 0.0f, 1.0f - xy.x);
    }
    return xyz;
}

__DEVICE__ float3 XYZ_to_xyY(float3 xyz, float2 white_xy) {
    if (xyz.y == 0.0f) {
        return make_float3(white_xy.x, white_xy.y, 0.0f);
    }
    float sum = xyz.x + xyz.y + xyz.z;
    float x = xyz.x / sum;
    float y = xyz.y / sum;
    float Y = xyz.y;
    return make_float3(x, y, Y);
}

__DEVICE__ float2 XYZ_to_xy(float3 xyz, float2 white_xy) {
    float3 xyY = XYZ_to_xyY(xyz, white_xy);
    return make_float2(xyY.x, xyY.y);
}

__DEVICE__ float2 standard_observer_to_camera_observer(float2 xy, float xyz_to_rgb[3][3], int camera_gamut) {
    // Takes xy coordinates in terms of the standard observer and converts them to the camera observer
    if (camera_gamut == SRC_GAMUT_XYZ) {
        return xy;
    }
    float3 xyz = xy_to_XYZ(xy);
    float3 rgb = mv_33_3(xyz_to_rgb, xyz);
    float2 new_xy = XYZ_to_xy(rgb, make_float2(1.0f / 3.0f, 1.0f / 3.0f));
    return new_xy;
}

__DEVICE__ float2 camera_observer_to_standard_observer(float2 xy, float rgb_to_xyz[3][3], int camera_gamut) {
    // Takes xy coordinates in terms of the camera observer and converts them to the standard observer
    if (camera_gamut == SRC_GAMUT_XYZ) {
        return xy;
    }
    float3 rgb = xy_to_XYZ(xy);
    float3 xyz = mv_33_3(rgb_to_xyz, rgb);
    float2 new_xy = XYZ_to_xy(xyz, make_float2(1.0f / 3.0f, 1.0f / 3.0f));
    return new_xy;
}

__DEVICE__ void make_sat_matrix(float mat[3][3], float sat, float3 lum_coeffs) {
    float sr = (1.0f - sat) * lum_coeffs.x;
    float sg = (1.0f - sat) * lum_coeffs.y;
    float sb = (1.0f - sat) * lum_coeffs.z;

    mat[0][0] = sr + sat;
    mat[0][1] = sr;
    mat[0][2] = sr;
    mat[1][0] = sg;
    mat[1][1] = sg + sat;
    mat[1][2] = sg;
    mat[2][0] = sb;
    mat[2][1] = sb;
    mat[2][2] = sb + sat;
}

__DEVICE__ void rgb_to_XYZ_mat_from_gamut(float dest[3][3], gamut_primaries_t primaries) {
    // From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
    float3 red_xyz = xy_to_XYZ(primaries.red_xy);
    float3 green_xyz = xy_to_XYZ(primaries.green_xy);
    float3 blue_xyz = xy_to_XYZ(primaries.blue_xy);
    float3 white_xyz = xy_to_XYZ(primaries.white_xy);

    float temp[3][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    temp[0][0] = red_xyz.x;
    temp[1][0] = red_xyz.y;
    temp[2][0] = red_xyz.z;
    temp[0][1] = green_xyz.x;
    temp[1][1] = green_xyz.y;
    temp[2][1] = green_xyz.z;
    temp[0][2] = blue_xyz.x;
    temp[1][2] = blue_xyz.y;
    temp[2][2] = blue_xyz.z;
    copy_mat_33(dest, temp); // dest is now cols of { red_xyz, green_xyz, blue_xyz }

    float temp2[3][3] = {};
    mat_inverse_33(temp2, temp);

    float3 s = mv_33_3(temp2, white_xyz);
    for (int r = 0; r < 3; ++r) {
        dest[r][0] *= s.x;
        dest[r][1] *= s.y;
        dest[r][2] *= s.z;
    }
}

__DEVICE__ gamut_primaries_t get_gamut_primaries(int gamut, gamut_primaries_t default_gamut) {

    switch (gamut) {
        case SRC_GAMUT_ACES_AP0:
            return make_gamut_primaries(
                make_float2(0.7347f, 0.2653f), make_float2(0.0f, 1.0f), make_float2(0.0001f, -0.0770f), make_float2(0.32168f, 0.33767f));
        case SRC_GAMUT_ACES_AP1:
            return make_gamut_primaries(
                make_float2(0.713f, 0.293f), make_float2(0.165f, 0.830f), make_float2(0.128f, 0.0444f), make_float2(0.32168f, 0.33767f));
        case SRC_GAMUT_AWG3:
            return make_gamut_primaries(
                make_float2(0.6840f, 0.3130f), make_float2(0.2210f, 0.8480f), make_float2(0.0861f, -0.1020f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_AWG4:
            return make_gamut_primaries(
                make_float2(0.7347f, 0.2653f), make_float2(0.1424f, 0.8576f), make_float2(0.0991f, -0.0308f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_CANON_CINEMA_GAMUT:
            return make_gamut_primaries(make_float2(0.74f, 0.27f), make_float2(0.17f, 1.14f), make_float2(0.08f, -0.1f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_DWG:
            return make_gamut_primaries(
                make_float2(0.8000f, 0.3130f), make_float2(0.1682f, 0.9877f), make_float2(0.0790f, -0.1155f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_EGAMUT:
            return make_gamut_primaries(
                make_float2(0.8000f, 0.3177f), make_float2(0.1800f, 0.9000f), make_float2(0.0650f, -0.0805f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_EGAMUT2:
            return make_gamut_primaries(
                make_float2(0.83f, 0.31f), make_float2(0.15f, 0.95f), make_float2(0.065f, -0.0805f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_P3_D65:
            return make_gamut_primaries(
                make_float2(0.680f, 0.320f), make_float2(0.265f, 0.690f), make_float2(0.150f, 0.060f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_REC709:
            return make_gamut_primaries(make_float2(0.64f, 0.33f), make_float2(0.30f, 0.60f), make_float2(0.15f, 0.06f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_REC2020:
            return make_gamut_primaries(
                make_float2(0.708f, 0.292f), make_float2(0.170f, 0.797f), make_float2(0.131f, 0.046f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_REDWIDEGAMUTRGB:
            return make_gamut_primaries(
                make_float2(0.780308f, 0.304253f), make_float2(0.121595f, 1.493994f), make_float2(0.095612f, -0.084589f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_SGAMUT3:
            return make_gamut_primaries(
                make_float2(0.730f, 0.280f), make_float2(0.140f, 0.855f), make_float2(0.100f, -0.050f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_SGAMUT3CINE:
            return make_gamut_primaries(
                make_float2(0.766f, 0.275f), make_float2(0.225f, 0.800f), make_float2(0.089f, -0.087f), make_float2(0.3127f, 0.3290f));
        case SRC_GAMUT_XYZ:
            return make_gamut_primaries(make_float2(1.0f, 0.0f), make_float2(0.0f, 1.0f), make_float2(0.0f, 0.0f), make_float2(1.0f / 3.0f, 1.0f / 3.0f));
        case SRC_GAMUT_CUSTOM:
        default:
            return default_gamut;
    }
}

// Wavelength step size
#define WAVELENGTH_STEP (5)
// num entries in below table
#define NUM_CMFS (82)

__CONSTANT__ float xyz_cmfs[NUM_CMFS][3] = {
    {0.001368f, 0.000039f, 0.006450f}, // 380nm
    {0.002236f, 0.000064f, 0.010550f}, //
    {0.004243f, 0.000120f, 0.020050f}, //
    {0.007650f, 0.000217f, 0.036210f}, //
    {0.014310f, 0.000396f, 0.067850f}, //
    {0.023190f, 0.000640f, 0.110200f}, //
    {0.043510f, 0.001210f, 0.207400f}, //
    {0.077630f, 0.002180f, 0.371300f}, //
    {0.134380f, 0.004000f, 0.645600f}, //
    {0.214770f, 0.007300f, 1.039050f}, //
    {0.283900f, 0.011600f, 1.385600f}, //
    {0.328500f, 0.016840f, 1.622960f}, //
    {0.348280f, 0.023000f, 1.747060f}, //
    {0.348060f, 0.029800f, 1.782600f}, //
    {0.336200f, 0.038000f, 1.772110f}, //
    {0.318700f, 0.048000f, 1.744100f}, //
    {0.290800f, 0.060000f, 1.669200f}, //
    {0.251100f, 0.073900f, 1.528100f}, //
    {0.195360f, 0.090980f, 1.287640f}, //
    {0.142100f, 0.112600f, 1.041900f}, //
    {0.095640f, 0.139020f, 0.812950f}, //
    {0.057950f, 0.169300f, 0.616200f}, //
    {0.032010f, 0.208020f, 0.465180f}, //
    {0.014700f, 0.258600f, 0.353300f}, //
    {0.004900f, 0.323000f, 0.272000f}, //
    {0.002400f, 0.407300f, 0.212300f}, //
    {0.009300f, 0.503000f, 0.158200f}, //
    {0.029100f, 0.608200f, 0.111700f}, //
    {0.063270f, 0.710000f, 0.078250f}, //
    {0.109600f, 0.793200f, 0.057250f}, //
    {0.165500f, 0.862000f, 0.042160f}, //
    {0.225750f, 0.914850f, 0.029840f}, //
    {0.290400f, 0.954000f, 0.020300f}, //
    {0.359700f, 0.980300f, 0.013400f}, //
    {0.433450f, 0.994950f, 0.008750f}, //
    {0.512050f, 1.000000f, 0.005750f}, //
    {0.594500f, 0.995000f, 0.003900f}, //
    {0.678400f, 0.978600f, 0.002750f}, //
    {0.762100f, 0.952000f, 0.002100f}, //
    {0.842500f, 0.915400f, 0.001800f}, //
    {0.916300f, 0.870000f, 0.001650f}, //
    {0.978600f, 0.816300f, 0.001400f}, //
    {1.026300f, 0.757000f, 0.001100f}, //
    {1.056700f, 0.694900f, 0.001000f}, //
    {1.062200f, 0.631000f, 0.000800f}, //
    {1.045600f, 0.566800f, 0.000600f}, //
    {1.002600f, 0.503000f, 0.000340f}, //
    {0.938400f, 0.441200f, 0.000240f}, //
    {0.854450f, 0.381000f, 0.000190f}, //
    {0.751400f, 0.321000f, 0.000100f}, //
    {0.642400f, 0.265000f, 0.000050f}, //
    {0.541900f, 0.217000f, 0.000030f}, //
    {0.447900f, 0.175000f, 0.000020f}, //
    {0.360800f, 0.138200f, 0.000010f}, //
    {0.283500f, 0.107000f, 0.000000f}, //
    {0.218700f, 0.081600f, 0.000000f}, //
    {0.164900f, 0.061000f, 0.000000f}, //
    {0.121200f, 0.044580f, 0.000000f}, //
    {0.087400f, 0.032000f, 0.000000f}, //
    {0.063600f, 0.023200f, 0.000000f}, //
    {0.046770f, 0.017000f, 0.000000f}, //
    {0.032900f, 0.011920f, 0.000000f}, //
    {0.022700f, 0.008210f, 0.000000f}, //
    {0.015840f, 0.005723f, 0.000000f}, //
    {0.011359f, 0.004102f, 0.000000f}, //
    {0.008111f, 0.002929f, 0.000000f}, //
    {0.005790f, 0.002091f, 0.000000f}, //
    {0.004109f, 0.001484f, 0.000000f}, //
    {0.002899f, 0.001047f, 0.000000f}, //
    {0.002049f, 0.000740f, 0.000000f}, //
    {0.001440f, 0.000520f, 0.000000f}, //
    {0.001000f, 0.000361f, 0.000000f}, //
    {0.000690f, 0.000249f, 0.000000f}, //
    {0.000476f, 0.000172f, 0.000000f}, //
    {0.000332f, 0.000120f, 0.000000f}, //
    {0.000235f, 0.000085f, 0.000000f}, //
    {0.000166f, 0.000060f, 0.000000f}, //
    {0.000117f, 0.000042f, 0.000000f}, //
    {0.000083f, 0.000030f, 0.000000f}, //
    {0.000059f, 0.000021f, 0.000000f}, //
    {0.000042f, 0.000015f, 0.000000f}, // 780nm
    {0.001368f, 0.000039f, 0.006450f}, // repeat of first entry
};

__DEVICE__ bool is_near_line_segment(float2 segment_start, float2 segment_end, float2 curr_pos, float eps) {
    float2 segment_vector = segment_end - segment_start;
    float2 point_vector = curr_pos - segment_start;
    float segment_length = _hypotf(segment_vector.x, segment_vector.y);
    float projection_length =
        dot_product(make_float3(segment_vector.x, segment_vector.y, 0.0f), make_float3(point_vector.x, point_vector.y, 0.0f)) / segment_length;
    float2 projection_point = segment_start + (segment_vector * (projection_length / segment_length));
    float distance_to_segment = _hypotf(curr_pos.x - projection_point.x, curr_pos.y - projection_point.y);

    return (distance_to_segment < eps && projection_length >= 0.0f && projection_length <= segment_length);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB) {

    float3 input_color = make_float3(_tex2D(p_TexR, p_X, p_Y), _tex2D(p_TexG, p_X, p_Y), _tex2D(p_TexB, p_X, p_Y));
    float3 output_color = input_color;
    dot_size /= 1000.0f;

    gamut_primaries_t custom_source_primaries = make_gamut_primaries(make_float2(source_red_x, source_red_y),
                                                                     make_float2(source_green_x, source_green_y),
                                                                     make_float2(source_blue_x, source_blue_y),
                                                                     make_float2(source_white_x, source_white_y));
    gamut_primaries_t source_primaries = get_gamut_primaries(source_gamut, custom_source_primaries);

    gamut_primaries_t overlay_primaries = get_gamut_primaries(overlay_gamut, custom_source_primaries);

    // Compute histogram bounds
    int box_size = (int)(_fminf((float)p_Height, (float)p_Width) * scope_size);

    bounding_box_t histogram_bounding_box =
        make_bounding_box(make_int2((int)(scope_pos_x * p_Width), (int)(scope_pos_y * p_Height)),
                          make_int2((int)(scope_pos_x * p_Width + box_size), (int)(scope_pos_y * p_Height + box_size)));

    bounding_box_t histogram_margin =
        make_bounding_box(make_int2((int)(p_Width - box_size), (int)(p_Height - box_size)), make_int2((int)(p_Width), (int)(p_Height)));
    histogram_bounding_box.left_bottom.x = min(histogram_bounding_box.left_bottom.x, histogram_margin.left_bottom.x);
    histogram_bounding_box.left_bottom.y = min(histogram_bounding_box.left_bottom.y, histogram_margin.left_bottom.y);
    histogram_bounding_box.right_top.x = min(histogram_bounding_box.right_top.x, histogram_margin.right_top.x);
    histogram_bounding_box.right_top.y = min(histogram_bounding_box.right_top.y, histogram_margin.right_top.y);
    float2 curr_pos = make_float2((float)p_X, (float)p_Height - 1.0f - p_Y);

    float to_xyz_33[3][3] = {};
    rgb_to_XYZ_mat_from_gamut(to_xyz_33, source_primaries);

    float xyz_to_working_33[3][3] = {};
    mat_inverse_33(xyz_to_working_33, to_xyz_33);

    if (inside_bounding_box(curr_pos, histogram_bounding_box)) {
        float3 histogram_color = make_float3(0.0f, 0.0f, 0.0f);
        const float2 middle = make_float2(1.0f / 3.0f, 1.0f / 3.0f);
        const float2 low_bound = middle - (1.0f / zoom) * middle;
        const float2 upper_bound = middle + (1.0f / zoom) * (make_float2(1.0f, 1.0f) - middle);

        float2 position_within_histogram = make_float2(_mix(low_bound.x, upper_bound.x, (curr_pos.x - histogram_bounding_box.left_bottom.x) / box_size),
                                                       _mix(low_bound.x, upper_bound.x, (curr_pos.y - histogram_bounding_box.left_bottom.y) / box_size));
        // Draw some triangles for the current gamut and the overall bounds
        float2 triangle_axes[3][3][2] = {
            // xyY CIE standard observer coordinates
            {
                {source_primaries.red_xy, source_primaries.green_xy},
                {source_primaries.green_xy, source_primaries.blue_xy},
                {source_primaries.blue_xy, source_primaries.red_xy},
            },
            {
                {make_float2(0.0f, 0.0f), make_float2(1.0f, 0.0f)},
                {make_float2(1.0f, 0.0f), make_float2(0.0f, 1.0f)},
                {make_float2(0.0f, 0.0f), make_float2(0.0f, 1.0f)},
            },
            {
                {overlay_primaries.red_xy, overlay_primaries.green_xy},
                {overlay_primaries.green_xy, overlay_primaries.blue_xy},
                {overlay_primaries.blue_xy, overlay_primaries.red_xy},
            },
        };

        float3 line_color[3] = {
            make_float3(1.0f, 1.0f, 1.0f), // current gamut
            make_float3(0.1f, 0.1f, 0.0f), // XYZ
            make_float3(0.3f, 0.3f, 0.3f), // overlay
        };

        bool draw_triangle_toggle[3] = {draw_target_triangle > 0, draw_xyz_triangle > 0, draw_overlay_triangle > 0};

        // Draw grid
        if (draw_grid) {
            if (_fabs(_fmod(position_within_histogram.x, 0.10f)) < dot_size || _fabs(_fmod(position_within_histogram.y, 0.10f)) < dot_size) {
                histogram_color = make_float3(0.05f, 0.05f, 0.05f);
            }
        }

        for (int i = 0; i < 3; ++i) {
            if (draw_triangle_toggle[i]) {
                for (int axis = 0; axis < 3; ++axis) {
                    float2 segment_start = triangle_axes[i][axis][0];
                    float2 segment_end = triangle_axes[i][axis][1];
                    if (invert) {
                        segment_start = standard_observer_to_camera_observer(segment_start, xyz_to_working_33, source_gamut);
                        segment_end = standard_observer_to_camera_observer(segment_end, xyz_to_working_33, source_gamut);
                    }
                    if (is_near_line_segment(segment_start, segment_end, position_within_histogram, dot_size)) {
                        histogram_color = line_color[i];
                    }
                }
            }
        }

        if (draw_spectral_locus) {
            for (int i = 0; i < (NUM_CMFS - 1); ++i) {
                float2 segment_start = XYZ_to_xy(make_float3(xyz_cmfs[i][0], xyz_cmfs[i][1], xyz_cmfs[i][2]), source_primaries.white_xy);
                float2 segment_end = XYZ_to_xy(make_float3(xyz_cmfs[i + 1][0], xyz_cmfs[i + 1][1], xyz_cmfs[i + 1][2]), source_primaries.white_xy);
                if (invert) {
                    segment_start = standard_observer_to_camera_observer(segment_start, xyz_to_working_33, source_gamut);
                    segment_end = standard_observer_to_camera_observer(segment_end, xyz_to_working_33, source_gamut);
                }
                if (is_near_line_segment(segment_start, segment_end, position_within_histogram, dot_size)) {
                    if (invert) {
                        // histogram_color = mv_33_3(to_xyz_33, xy_to_XYZ(position_within_histogram));
                        histogram_color = xy_to_XYZ(camera_observer_to_standard_observer(position_within_histogram, to_xyz_33, source_gamut));
                    } else {
                        histogram_color = mv_33_3(xyz_to_working_33, xy_to_XYZ(position_within_histogram));
                    }
                    histogram_color /= _fmaxf(histogram_color.x, _fmaxf(histogram_color.y, histogram_color.z)) + 1e-6f;
                }
            }
        }

        if (draw_white_point) {
            float2 white_point = source_primaries.white_xy;
            if (invert) {
                white_point = standard_observer_to_camera_observer(white_point, xyz_to_working_33, source_gamut);
            }
            if (_hypotf(position_within_histogram.x - white_point.x, position_within_histogram.y - white_point.y) < 3.0f * dot_size) {
                histogram_color = make_float3(1.0f, 1.0f, 1.0f);
            }
        }

        // Draw interior dots
        bool skip_additional_samples = false;
        for (int sample_idx_x = 0; sample_idx_x < num_x_samples && !skip_additional_samples; ++sample_idx_x) {
            for (int sample_idx_y = 0; sample_idx_y < num_y_samples && !skip_additional_samples; ++sample_idx_y) {
                int2 curr_sample_pos =
                    make_int2((int)((sample_idx_x + 0.5f) / (num_x_samples)*p_Width), (int)((sample_idx_y + 0.5f) / (num_y_samples)*p_Height));
                float3 curr_color = make_float3(_tex2D(p_TexR, curr_sample_pos.x, curr_sample_pos.y),
                                                _tex2D(p_TexG, curr_sample_pos.x, curr_sample_pos.y),
                                                _tex2D(p_TexB, curr_sample_pos.x, curr_sample_pos.y));

                if (_sqrtf(curr_color.x * curr_color.x + curr_color.y * curr_color.y + curr_color.z * curr_color.z) < ignore_magnitude_below) {
                    // Skip samples whose magnitude is below the specified threshold, as they tend to have
                    // high chromaticity just due to noise.
                    continue;
                }
                float2 curr_dot_histogram_pos;
                float3 curr_color_xyz = mv_33_3(to_xyz_33, curr_color);
                if (curr_color_xyz.x + curr_color_xyz.y + curr_color_xyz.z <= ignore_xyz_sum_below) {
                    continue;
                }
                float2 curr_color_xy = XYZ_to_xy(curr_color_xyz, source_primaries.white_xy);
                if (invert) {
                    curr_color_xy = standard_observer_to_camera_observer(curr_color_xy, xyz_to_working_33, source_gamut);
                }
                float2 dot_center = curr_color_xy;
                if (_hypotf(position_within_histogram.x - dot_center.x, position_within_histogram.y - dot_center.y) < dot_size) {
                    histogram_color = _mix(histogram_color, curr_color / ((curr_color.x + curr_color.y + curr_color.z) / 3.0f), dot_opacity);
                    skip_additional_samples = dot_opacity > 0.998f;
                }
            }
        }

        float sat_matrix[3][3] = {};
        make_sat_matrix(sat_matrix, scope_saturation, make_float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
        histogram_color = mv_33_3(sat_matrix, histogram_color);

        output_color = _mix(input_color, histogram_color, scope_opacity);
    }

    return output_color;
}