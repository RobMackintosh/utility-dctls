DEFINE_UI_PARAMS(exposure, Exposure Adjustment, DCTLUI_SLIDER_FLOAT, 0.0, -8.0, 8.0, 0.333)
DEFINE_UI_PARAMS(outer_border_width, Outer Border Width, DCTLUI_SLIDER_FLOAT, 0.01, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(inner_border_width, Inner Border Width, DCTLUI_SLIDER_FLOAT, 0.05, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(dataset, Dataset, DCTLUI_COMBO_BOX, 0, {OFFICIAL, MCCAMY}, {Official XRite, McCamy})
DEFINE_UI_PARAMS(convert_illuminant, Adapt to, DCTLUI_COMBO_BOX, 1, {CAT_NOTHING, CAT_D65, CAT_ACES}, {Nothing, D65, ACES})

__DEVICE__ float3 xy_to_XYZ(float2 xy) {
    float x = xy.x;
    float y = xy.y;
    if (y == 0.0f) {
        return make_float3(x, 0.0f, 1.0f - x);
    }
    float3 out = make_float3(x / y, 1.0f, (1 - x - y) / y);
    return out;
}

__CONSTANT__ float colors_official[24][3] = {
    // Copied from X-Rite website Colorchecker after 2014 LAB measurements
    // LAB coordinates of the 24 color chips were allegedly under M0 (tungsten) lighting condition.
    // However, this M0 seems to be untrustworthy and therefore we should assume they were under M1 (D50) conditions.
    {37.54f, 14.37f, 14.92f},   // Dark Skin
    {64.66f, 19.27f, 17.5f},    // Light skin
    {49.32f, -3.82f, -22.54f},  // blue sky
    {43.46f, -12.74f, 22.72f},  // foliage
    {54.94f, 9.61f, -24.79f},   // blue flower
    {70.48f, -32.26f, -0.37f},  // bluish green
    {62.73f, 35.83f, 56.5f},    // orange
    {39.43f, 10.75f, -45.17f},  // purplish blue
    {50.57f, 48.64f, 16.67f},   // moderate red
    {30.1f, 22.54f, -20.87f},   // purple
    {71.77f, -24.13f, 58.19f},  // yellow green
    {71.51f, 18.24f, 67.37f},   // orange yellow
    {28.37f, 15.42f, -49.8f},   // blue
    {54.38f, -39.72f, 32.27f},  // green
    {42.43f, 51.05f, 28.62f},   // red
    {81.8f, 2.67f, 80.41f},     // yellow
    {50.63f, 51.28f, -14.12f},  // magenta
    {49.57f, -29.71f, -28.32f}, // cyan
    {95.19f, -1.03f, 2.93f},    // white
    {81.29f, -0.57f, 0.44f},    // neutral 8
    {66.89f, -0.75f, -0.06f},   // neutral 6.5f
    {50.76f, -0.13f, 0.14f},    // neutral 5
    {35.63f, -0.46f, -0.48f},   // neutral 3.5f
    {20.64f, 0.07f, -0.46f},    // black
};

// Original Paper values
__CONSTANT__ float colors_mccamy[24][3] = {
    // xyY coordinates of the 24 color chips.
    {0.4002f, 0.3504f, 0.1005f}, // Dark Skin
    {0.3773f, 0.3446f, 0.3582f}, // Light skin
    {0.2470f, 0.2514f, 0.1933f}, // blue sky
    {0.3372f, 0.4220f, 0.1329f}, // foliage
    {0.2651f, 0.2400f, 0.2427f}, // blue flower
    {0.2608f, 0.3430f, 0.4306f}, // bluish green
    {0.5060f, 0.4070f, 0.3005f}, // orange
    {0.2110f, 0.1750f, 0.1200f}, // purplish blue
    {0.4533f, 0.3058f, 0.1977f}, // moderate red
    {0.2845f, 0.2020f, 0.0656f}, // purple
    {0.3800f, 0.4887f, 0.4429f}, // yellow green
    {0.4729f, 0.4375f, 0.4306f}, // orange yellow
    {0.1866f, 0.1285f, 0.0611f}, // blue
    {0.3046f, 0.4782f, 0.2339f}, // green
    {0.5385f, 0.3129f, 0.1200f}, // red
    {0.4480f, 0.4703f, 0.5910f}, // yellow
    {0.3635f, 0.2325f, 0.1977f}, // magenta
    {0.1958f, 0.2519f, 0.1977f}, // cyan
    {0.3101f, 0.3163f, 0.9001f}, // white
    {0.3101f, 0.3163f, 0.5910f}, // neutral 8
    {0.3101f, 0.3163f, 0.3620f}, // neutral 6.5f
    {0.3101f, 0.3163f, 0.1977f}, // neutral 5
    {0.3101f, 0.3163f, 0.0900f}, // neutral 3.5f
    {0.3101f, 0.3163f, 0.0313f}, // black
};

__DEVICE__ float dot_product(float3 a, float3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

// Matrix math
__DEVICE__ float3 mv_33_3(float mat[3][3], float3 v) {
    // matrix * vector multiplication
    float3 out = make_float3(mat[0][0] * v.x + mat[0][1] * v.y + mat[0][2] * v.z,
                             mat[1][0] * v.x + mat[1][1] * v.y + mat[1][2] * v.z,
                             mat[2][0] * v.x + mat[2][1] * v.y + mat[2][2] * v.z);
    return out;
}

__DEVICE__ void copy_mat_33(float to[3][3], float from[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            to[i][j] = from[i][j];
        }
    }
}

__DEVICE__ void mm_33_33(float dest[3][3], float a[3][3], float b[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = dot_product(make_float3(a[i][0], a[i][1], a[i][2]), make_float3(b[0][j], b[1][j], b[2][j]));
        }
    }
}

__DEVICE__ void mat_inverse_33(float m[3][3]) {
    // from https://ardoris.wordpress.com/2008/07/18/general-formula-for-the-inverse-of-a-3x3-matrix/
    float inv_buf[3][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};

    float det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

    inv_buf[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
    inv_buf[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
    inv_buf[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
    inv_buf[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
    inv_buf[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
    inv_buf[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
    inv_buf[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
    inv_buf[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
    inv_buf[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
    copy_mat_33(m, inv_buf);
}

__DEVICE__ void mat_fill(float dest[3][3], float fill) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = fill;
        }
    }
}

__DEVICE__ void diagonal_matrix(float dest[3][3], float3 diagonal) {
    mat_fill(dest, 0.0f);
    dest[0][0] = diagonal.x;
    dest[1][1] = diagonal.y;
    dest[2][2] = diagonal.z;
}

__DEVICE__ void cat02_adaptation_matrix(float dest[3][3], float2 source_white_xy, float2 dest_white_xy) {

    float cat02[3][3] = {
        {0.7328f, 0.4296f, -0.1624f},
        {-0.7036f, 1.6975f, 0.0061f},
        {0.003f, 0.0136f, 0.9834f},
    };
    float cat02_inv[3][3] = {};
    copy_mat_33(cat02_inv, cat02);
    mat_inverse_33(cat02_inv);

    float3 source_white = xy_to_XYZ(source_white_xy);
    float3 dest_white = xy_to_XYZ(dest_white_xy);
    float3 source_lms = mv_33_3(cat02, source_white);
    float3 dest_lms = mv_33_3(cat02, dest_white);
    float diag[3][3] = {};
    diagonal_matrix(diag, dest_lms / source_lms);
    float temp[3][3] = {};
    mm_33_33(temp, diag, cat02);
    mm_33_33(dest, cat02_inv, temp);
}

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ float3 LAB_to_XYZ(float3 lab, float2 illuminant_xy) {
    // Adapted from Jan Karow's implementation.
    float Xr = illuminant_xy.x / illuminant_xy.y * 100.0f;
    float Yr = 100.0f;
    float Zr = (1.0f - illuminant_xy.x - illuminant_xy.y) / illuminant_xy.y * 100.0f;
    float E = 216.0f / 24389.0f;
    float K = 24389.0f / 27.0f;

    float L = lab.x, a = lab.y, b = lab.z;

    // Lab to XYZ
    float fy = (L + 16.0f) / 116.0f;
    float fx = a / 500.0f + fy;
    float fz = fy - b / 200.0f;

    float xr = powf(fx, 3.0f) > E ? powf(fx, 3.0f) : (116.0f * fx - 16.0f) / K;
    float yr = L > (K * E) ? powf((L + 16.0f) / 116.0f, 3.0f) : L / K;
    float zr = powf(fz, 3.0f) > E ? powf(fz, 3.0f) : (116.0f * fz - 16.0f) / K;

    float X = xr * Xr / 100.0f;
    float Y = yr * Yr / 100.0f;
    float Z = zr * Zr / 100.0f;

    return make_float3(X, Y, Z);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float x = (float)p_X / (float)p_Width;
    float y = (float)p_Y / (float)p_Height;

    float3 output = make_float3(0.0f, 0.0f, 0.0f);

    float usable_area = 1.0f - 2 * outer_border_width;
    float col = ((x - 0.5f) / usable_area + 0.5f) * 6.0f;
    float row = ((y - 0.5f) / usable_area + 0.5f) * 4.0f;

    if (col < 0 || row < 0 || col >= 6 || row >= 4) {
        return output;
    }
    float inner_posx = _fmod(col, 1.0f);
    float inner_posy = _fmod(row, 1.0f);
    if (inner_posx < inner_border_width || inner_posy < inner_border_width || inner_posx >= 1.0f - inner_border_width ||
        inner_posy >= 1.0f - inner_border_width) {
        return output;
    }

    // Get current color
    int idx = (int)col + ((int)row * 6);
    float3 tile_color_XYZ;
    const float2 illuminant_d65 = make_float2(0.3127f, 0.3290f);    // D65
    const float2 illuminant_d50 = make_float2(0.34567f, 0.35850f);  // D50
    const float2 illuminant_c = make_float2(0.3101f, 0.3163f);      // C
    const float2 illuminant_aces = make_float2(0.32168f, 0.33767f); // ACES

    float2 source_illuminant;
    if (dataset == OFFICIAL) {
        float3 tile_color_LAB = make_float3(colors_official[idx][0], colors_official[idx][1], colors_official[idx][2]);

        tile_color_XYZ = LAB_to_XYZ(tile_color_LAB, illuminant_d50);
        source_illuminant = illuminant_d50;
    } else if (dataset == MCCAMY) {
        float3 tile_color_xyY = make_float3(colors_mccamy[idx][0], colors_mccamy[idx][1], colors_mccamy[idx][2]);

        tile_color_XYZ = make_float3(tile_color_xyY.x * tile_color_xyY.z / tile_color_xyY.y,
                                     tile_color_xyY.z,
                                     ((1 - tile_color_xyY.x - tile_color_xyY.y) * tile_color_xyY.z) / (tile_color_xyY.y));

        source_illuminant = illuminant_c;
    }

    float3 adapted_colors = tile_color_XYZ;

    if (convert_illuminant != CAT_NOTHING) {
        float2 dest_illuminant;
        float adaptation_matrix[3][3] = {};
        if (convert_illuminant == CAT_D65) {
            // Chromatic adaptation to D65.
            dest_illuminant = illuminant_d65;
        } else if (convert_illuminant == CAT_ACES) {
            // Chromatic adaptation to ACES.
            dest_illuminant = illuminant_aces;
        }
        cat02_adaptation_matrix(adaptation_matrix, source_illuminant, dest_illuminant);
        adapted_colors = mv_33_3(adaptation_matrix, tile_color_XYZ);
    }

    float exposure_gain = _powf(2.0f, exposure);
    adapted_colors.x *= exposure_gain;
    adapted_colors.y *= exposure_gain;
    adapted_colors.z *= exposure_gain;

    output = adapted_colors;
    return output;
}